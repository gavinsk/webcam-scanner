<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Webcam to PDF Scanner (Responsive Aspect Preview + Pointer Crop)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: sans-serif; text-align: center; margin: 20px; background: #f4f4f4; }
  #videoWrap { display:inline-block; max-width: 100%; }
  video {
    border: 2px solid #333; border-radius: 4px;
    display: block; margin: 0 auto;
  }
  #controls { margin-top: 8px; }
  button, select { margin: 5px; padding: 8px 12px; font-size: 14px; cursor: pointer; }
  #diag { font-size: 12px; color: #333; margin-top: 6px; }

  .thumb-container { display: inline-block; text-align: center; margin: 5px; background: white; padding: 5px; border-radius: 4px; }
  .thumb-container img { display: block; height: 120px; margin-bottom: 5px; border: 1px solid #ccc; cursor: pointer; }

  #cropModal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85);
               flex-direction: column; align-items: center; justify-content: flex-start; overflow: auto; padding: 20px; z-index: 2000; }
  #cropCanvas { background: white; cursor: crosshair; max-width: 95%; height: auto; touch-action: none; }
  .button-bar { position: sticky; bottom: 0; background: rgba(0,0,0,0.85); padding: 10px; display: flex; gap: 10px; justify-content: center; }

  #previewModal { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.9); justify-content:center; align-items:center; z-index:3000; }
  #previewImage { max-width:90%; max-height:90%; transform-origin: center center; transition: transform 0.2s ease; cursor: grab; }
  #closePreview { position:absolute; top:20px; right:20px; padding:8px 12px; font-size:16px; cursor:pointer; }
</style>
</head>
<body>

<h1>Webcam to PDF Scanner</h1>

<div id="videoWrap">
  <video id="video" autoplay playsinline></video>
</div>

<div id="controls">
  <button id="startBtn">üé• Start / Restart Camera</button>
  <label for="qualitySelect">PDF Quality:</label>
  <select id="qualitySelect">
    <option value="high" selected>High (Camera Max Resolution / Crop Actual)</option>
    <option value="standard">Standard (850√ó1100)</option>
  </select>
  <button id="captureBtn">üì∑ Capture Page (Enter)</button>
  <button id="downloadBtn">üíæ Download PDF</button>
  <button id="flipBtn" style="display:none;">üîÑ Flip Camera</button>
  <div id="diag"></div>
</div>

<div id="thumbnails"></div>

<!-- Crop Modal -->
<div id="cropModal">
  <canvas id="cropCanvas"></canvas>
  <div class="button-bar">
    <button id="applyCrop">‚úÖ Apply Crop</button>
    <button id="cancelCrop">‚ùå Cancel</button>
  </div>
</div>

<!-- Preview Modal -->
<div id="previewModal">
  <img id="previewImage" src="">
  <button id="closePreview">‚ùå Close</button>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"
        onload="cv['onRuntimeInitialized']=()=>{window.cvReady=true;}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
(async function(){
  const video = document.getElementById('video');
  const startBtn = document.getElementById('startBtn');
  const flipBtn = document.getElementById('flipBtn');
  const captureBtn = document.getElementById('captureBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const qualitySelect = document.getElementById('qualitySelect');
  const thumbnails = document.getElementById('thumbnails');
  const diag = document.getElementById('diag');
  const controls = document.getElementById('controls');

  const cropModal = document.getElementById('cropModal');
  const cropCanvas = document.getElementById('cropCanvas');
  const cropCtx = cropCanvas.getContext('2d');
  const applyCropBtn = document.getElementById('applyCrop');
  const cancelCropBtn = document.getElementById('cancelCrop');

  const previewModal = document.getElementById('previewModal');
  const previewImage = document.getElementById('previewImage');
  const closePreview = document.getElementById('closePreview');

  let currentStream = null;
  let currentFacingMode = 'environment'; // prefer rear
  let camW = 1280, camH = 720; // updated by actual stream
  let draggingPoint = null;
  // Touch-friendly target size in CSS pixels; converted to canvas pixels dynamically
const CSS_HANDLE_RADIUS = 18;
  let points = [];
  let croppingIndex = null;

  const capturedImages = [];

  // Ensure the crop canvas has a visible CSS size before measuring clientWidth/Height
  function ensureCropCanvasCssSize(){
    const rect = cropCanvas.getBoundingClientRect();
    if (!rect.width || !rect.height) {
      cropCanvas.style.maxWidth = "95vw";
      cropCanvas.style.width = Math.floor(window.innerWidth * 0.9) + "px";
      cropCanvas.style.height = "auto";
    }
  }
  window.addEventListener('resize', () => {
    if (cropModal.style.display === "flex") {
      ensureCropCanvasCssSize();
      drawCropOverlay();
    }
  });

  function setDiag(text) { diag.textContent = text; }

  // --- Responsive preview (preserve aspect) ---
  function resizePreview() {
    const vpW = Math.max(320, window.innerWidth - 40);
    const reserved = Math.max(160, controls.offsetHeight + 40);
    const vpH = Math.max(240, window.innerHeight - reserved);

    const ar = camW / camH;
    let drawW = vpW;
    let drawH = Math.round(drawW / ar);
    if (drawH > vpH) {
      drawH = vpH;
      drawW = Math.round(drawH * ar);
    }

    video.style.width = drawW + 'px';
    video.style.height = drawH + 'px';
  }
  window.addEventListener('resize', resizePreview);

  async function countCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d => d.kind === 'videoinput').length;
    } catch { return 1; }
  }

  async function tryGet(constraints) {
    try { return await navigator.mediaDevices.getUserMedia(constraints); }
    catch(e){ return null; }
  }

  async function startCamera(preferredFacing = currentFacingMode) {
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());

    const attempts = [
      { label: 'rear+max',   c: { video: { facingMode: { ideal: preferredFacing }, width: { ideal: 9999 }, height: { ideal: 9999 } } } },
      { label: 'rear',       c: { video: { facingMode: { ideal: preferredFacing } } } },
      { label: 'front',      c: { video: { facingMode: { ideal: (preferredFacing==='environment'?'user':'environment') } } } },
      { label: 'any',        c: { video: true } },
    ];

    let used = null, stream = null;
    for (const a of attempts) {
      stream = await tryGet(a.c);
      if (stream) { used = a.label; break; }
    }

    if (!stream) {
      alert('Unable to access camera. Try HTTPS or open in a new tab if embedded.');
      setDiag('Failed to start camera.');
      return;
    }

    currentStream = stream;
    video.srcObject = stream;
    await new Promise(res => video.onloadedmetadata = res);

    camW = video.videoWidth || camW;
    camH = video.videoHeight || camH;
    setDiag(`Camera: ${used} | Resolution: ${camW}√ó${camH}`);
    flipBtn.style.display = (await countCameras()) > 1 ? 'inline-block' : 'none';

    resizePreview();
  }

  startBtn.onclick = () => startCamera();
  flipBtn.onclick = async () => {
    currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
    await startCamera(currentFacingMode);
  };

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') captureBtn.click();
  });

  function renderThumbnails(){
    thumbnails.innerHTML = "";
    capturedImages.forEach((imgObj, index) => {
      const container = document.createElement('div');
      container.className = "thumb-container";
      const img = document.createElement('img');
      img.src = imgObj.data;
      img.onclick = () => openPreview(imgObj.data);
      container.appendChild(img);

      const rotateBtn = document.createElement('button');
      rotateBtn.textContent = "üîÑ Rotate";
      rotateBtn.onclick = () => {
        const tempCanvas = document.createElement('canvas');
        const ctx = tempCanvas.getContext('2d');
        tempCanvas.width = imgObj.height;
        tempCanvas.height = imgObj.width;
        ctx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(imgObj.imageElement, -imgObj.width / 2, -imgObj.height / 2);
        imgObj.data = tempCanvas.toDataURL('image/jpeg', 1.0);
        imgObj.width = tempCanvas.width;
        imgObj.height = tempCanvas.height;
        imgObj.imageElement = new Image();
        imgObj.imageElement.src = imgObj.data;
        imgObj.imageElement.onload = renderThumbnails;
      };
      container.appendChild(rotateBtn);

      const cropBtn = document.createElement('button');
      cropBtn.textContent = "‚úÇÔ∏è Crop";
      cropBtn.onclick = () => startCropping(index);
      container.appendChild(cropBtn);

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = "üóë Delete";
      deleteBtn.onclick = () => {
        capturedImages.splice(index, 1);
        renderThumbnails();
      };
      container.appendChild(deleteBtn);

      thumbnails.appendChild(container);
    });
  }

  captureBtn.onclick = () => {
    if (!video.srcObject) {
      alert('Start the camera first.');
      return;
    }
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);

    let targetWidth = (qualitySelect.value === "standard") ? 850 : video.videoWidth;
    let targetHeight = (qualitySelect.value === "standard") ? 1100 : video.videoHeight;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = targetWidth;
    tempCanvas.height = targetHeight;
    tempCanvas.getContext('2d').drawImage(canvas, 0, 0, targetWidth, targetHeight);

    const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);
    const imgElement = new Image();
    imgElement.src = imgData;
    imgElement.onload = () => {
      capturedImages.push({
        data: imgData,
        width: tempCanvas.width,
        height: tempCanvas.height,
        imageElement: imgElement
      });
      renderThumbnails();
    };
  };

  function startCropping(index){
    if (!window.cvReady) {
      alert("OpenCV.js is still loading, please try again in a moment.");
      return;
    }
    croppingIndex = index;
    const imgObj = capturedImages[index];

    // Set the internal canvas buffer to the image size first
    cropCanvas.width = imgObj.width;
    cropCanvas.height = imgObj.height;

    // 1) Make modal visible so Safari performs layout
    cropModal.style.display = "flex";

    // 2) Ensure the canvas has a CSS size so clientWidth/Height are non-zero
    ensureCropCanvasCssSize();

    // 3) Draw on the next frame after layout
    requestAnimationFrame(() => {
      cropCtx.drawImage(imgObj.imageElement, 0, 0);
      points = [
        {x: imgObj.width * 0.1, y: imgObj.height * 0.1},
        {x: imgObj.width * 0.9, y: imgObj.height * 0.1},
        {x: imgObj.width * 0.9, y: imgObj.height * 0.9},
        {x: imgObj.width * 0.1, y: imgObj.height * 0.9}
      ];
      drawCropOverlay();
    });
  }
    croppingIndex = index;
    const imgObj = capturedImages[index];
    cropCanvas.width = imgObj.width;
    cropCanvas.height = imgObj.height;
    cropCtx.drawImage(imgObj.imageElement, 0, 0);

    points = [
      {x: imgObj.width * 0.1, y: imgObj.height * 0.1},
      {x: imgObj.width * 0.9, y: imgObj.height * 0.1},
      {x: imgObj.width * 0.9, y: imgObj.height * 0.9},
      {x: imgObj.width * 0.1, y: imgObj.height * 0.9}
    ];
    drawCropOverlay();
    cropModal.style.display = "flex";
  }

  function drawCropOverlay(){
    const imgObj = capturedImages[croppingIndex];
    // Clear and redraw image
    cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
    cropCtx.drawImage(imgObj.imageElement, 0, 0);

    // Use client rect to compute scale; guard against zero in Safari pre-layout
    const rect = cropCanvas.getBoundingClientRect();
    const scale = rect.width > 0 ? (cropCanvas.width / rect.width) : 1;
    const handleR = Math.max(14, 18 * scale);
    const lineW   = Math.max(2, 2 * scale);

    // Outline
    cropCtx.strokeStyle = "red";
    cropCtx.lineWidth = lineW;
    cropCtx.beginPath();
    cropCtx.moveTo(points[0].x, points[0].y);
    for (let i = 1; i < points.length; i++) cropCtx.lineTo(points[i].x, points[i].y);
    cropCtx.closePath();
    cropCtx.stroke();

    // Handles
    cropCtx.fillStyle = "yellow";
    cropCtx.strokeStyle = "#333";
    cropCtx.lineWidth = lineW;
    points.forEach(p => {
      cropCtx.beginPath();
      cropCtx.arc(p.x, p.y, handleR, 0, 2 * Math.PI);
      cropCtx.fill();
      cropCtx.stroke();
    });
  });
  });
  }

  function getCanvasCoordsFromPointer(e) {
    const rect = cropCanvas.getBoundingClientRect();
    const scaleX = rect.width  > 0 ? (cropCanvas.width  / rect.width)  : 1;
    const scaleY = rect.height > 0 ? (cropCanvas.height / rect.height) : 1;
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top)  * scaleY
    };
  };
  };
  }

  cropCanvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    const { x, y } = getCanvasCoordsFromPointer(e);
    draggingPoint = null;
    points.forEach((p, idx) => {
      // Hit test using scaled radius in canvas pixels
    const scale = cropCanvas.width / cropCanvas.clientWidth || 1;
    const hitR  = Math.max(18, CSS_HANDLE_RADIUS * scale);
    const rect = cropCanvas.getBoundingClientRect();
    cons
    });
    if (draggingPoint !== null) cropCanvas.setPointerCapture?.(e.pointerId);
  });

  cropCanvas.addEventListener('pointermove', (e) => {
    if (draggingPoint === null) return;
    e.preventDefault();
    const { x, y } = getCanvasCoordsFromPointer(e);
    points[draggingPoint].x = x;
    points[draggingPoint].y = y;
    drawCropOverlay();
  });

  function endDrag(e) {
    if (draggingPoint !== null) {
      try { cropCanvas.releasePointerCapture?.(e.pointerId); } catch {}
    }
    draggingPoint = null;
  }
  cropCanvas.addEventListener('pointerup', endDrag);
  cropCanvas.addEventListener('pointercancel', endDrag);

  applyCropBtn.onclick = () => {
    const imgObj = capturedImages[croppingIndex];
    let dstW, dstH;
    if (qualitySelect.value === "standard") { dstW = 850; dstH = 1100; }
    else {
      dstW = Math.round(Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y));
      dstH = Math.round(Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y));
    }

    const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      points[0].x, points[0].y, points[1].x, points[1].y,
      points[2].x, points[2].y, points[3].x, points[3].y
    ]);
    const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
      0, 0, dstW - 1, 0, dstW - 1, dstH - 1, 0, dstH - 1
    ]);
    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const srcMat = cv.imread(imgObj.imageElement);
    const dst = new cv.Mat();
    cv.warpPerspective(srcMat, dst, M, new cv.Size(dstW, dstH));

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = dstW; tempCanvas.height = dstH;
    cv.imshow(tempCanvas, dst);

    imgObj.data = tempCanvas.toDataURL('image/jpeg', 1.0);
    imgObj.width = dstW; imgObj.height = dstH;
    imgObj.imageElement = new Image();
    imgObj.imageElement.src = imgObj.data;
    imgObj.imageElement.onload = renderThumbnails;

    srcTri.delete(); dstTri.delete(); M.delete(); srcMat.delete(); dst.delete();
    cropModal.style.display = "none";
  };

  cancelCropBtn.onclick = () => { cropModal.style.display = "none"; };

  downloadBtn.onclick = () => {
    if (!capturedImages.length) { alert("No pages captured!"); return; }
    const { jsPDF } = window.jspdf;
    let pdf = null;
    capturedImages.forEach((img, index) => {
      if (index === 0) {
        pdf = new jsPDF({
          orientation: img.width > img.height ? "landscape" : "portrait",
          unit: "px",
          format: [img.width, img.height]
        });
      } else {
        pdf.addPage([img.width, img.height], img.width > img.height ? "landscape" : "portrait");
      }
      pdf.addImage(img.data, 'JPEG', 0, 0, img.width, img.height);
    });
    pdf.save("scan.pdf");
  };

  closePreview.onclick = () => { previewModal.style.display = "none"; };
  function openPreview(src){ previewImage.src = src; previewModal.style.display = "flex"; }

  // Start camera and size preview
  window.addEventListener('load', () => { startCamera().catch(()=>{}); });
  video.addEventListener('loadedmetadata', () => {
    camW = video.videoWidth || camW;
    camH = video.videoHeight || camH;
    resizePreview();
  });
})();
</script>

</body>
</html>
