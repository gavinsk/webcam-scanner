<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Webcam to PDF Scanner (Responsive with Crop Fixes)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: sans-serif; text-align: center; margin: 20px; background: #f4f4f4; }
  #videoWrap { display:inline-block; max-width: 100%; }
  video {
    border: 2px solid #333; border-radius: 4px;
    display: block; margin: 0 auto;
  }
  #controls { margin-top: 8px; }
  button, select { margin: 5px; padding: 8px 12px; font-size: 14px; cursor: pointer; }
  #diag { font-size: 12px; color: #333; margin-top: 6px; }

  .thumb-container { display: inline-block; text-align: center; margin: 5px; background: white; padding: 5px; border-radius: 4px; }
  .thumb-container img { display: block; height: 120px; margin-bottom: 5px; border: 1px solid #ccc; cursor: pointer; }

  #cropModal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85);
               flex-direction: column; align-items: center; justify-content: flex-start; overflow: auto; padding: 20px; z-index: 2000; }
  #cropCanvas { background: white; cursor: crosshair; max-width: 95%; height: auto; touch-action: none; }
  .button-bar { position: sticky; bottom: 0; background: rgba(0,0,0,0.85); padding: 10px; display: flex; gap: 10px; justify-content: center; }

  #previewModal { display:none; position:fixed; inset:0; background: rgba(0,0,0,0.9); justify-content:center; align-items:center; z-index:3000; }
  #previewImage { max-width:90%; max-height:90%; transform-origin: center center; transition: transform 0.2s ease; cursor: grab; }
  #closePreview { position:absolute; top:20px; right:20px; padding:8px 12px; font-size:16px; cursor:pointer; }
</style>
</head>
<body>

<h1>Webcam to PDF Scanner</h1>

<div id="videoWrap">
  <video id="video" autoplay playsinline></video>
</div>

<div id="controls">
  <button id="startBtn">üé• Start / Restart Camera</button>
  <label for="qualitySelect">PDF Quality:</label>
  <select id="qualitySelect">
    <option value="high" selected>High (Camera Max Resolution / Crop Actual)</option>
    <option value="standard">Standard (850√ó1100)</option>
  </select>
  <button id="captureBtn">üì∑ Capture Page (Enter)</button>
  <button id="downloadBtn">üíæ Download PDF</button>
  <button id="flipBtn" style="display:none;">üîÑ Flip Camera</button>
  <div id="diag"></div>
</div>

<div id="thumbnails"></div>

<!-- Crop Modal -->
<div id="cropModal">
  <canvas id="cropCanvas"></canvas>
  <div class="button-bar">
    <button id="applyCrop">‚úÖ Apply Crop</button>
    <button id="cancelCrop">‚ùå Cancel</button>
  </div>
</div>

<!-- Preview Modal -->
<div id="previewModal">
  <img id="previewImage" src="">
  <button id="closePreview">‚ùå Close</button>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"
        onload="cv['onRuntimeInitialized']=()=>{window.cvReady=true;}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
(async function(){
  const video = document.getElementById('video');
  const startBtn = document.getElementById('startBtn');
  const flipBtn = document.getElementById('flipBtn');
  const captureBtn = document.getElementById('captureBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const qualitySelect = document.getElementById('qualitySelect');
  const thumbnails = document.getElementById('thumbnails');
  const diag = document.getElementById('diag');
  const controls = document.getElementById('controls');

  const cropModal = document.getElementById('cropModal');
  const cropCanvas = document.getElementById('cropCanvas');
  const cropCtx = cropCanvas.getContext('2d');
  const applyCropBtn = document.getElementById('applyCrop');
  const cancelCropBtn = document.getElementById('cancelCrop');

  const previewModal = document.getElementById('previewModal');
  const previewImage = document.getElementById('previewImage');
  const closePreview = document.getElementById('closePreview');

  let currentStream = null;
  let currentFacingMode = 'environment';
  let camW = 1280, camH = 720;
  let draggingPoint = null;
  const CSS_HANDLE_RADIUS = 18;
  let points = [];
  let croppingIndex = null;

  const capturedImages = [];

  // Ensure the crop canvas has a visible CSS size before measuring clientWidth/Height
  function ensureCropCanvasCssSize(){
    const rect = cropCanvas.getBoundingClientRect();
    if (!rect.width || !rect.height) {
      cropCanvas.style.maxWidth = "95vw";
      cropCanvas.style.width = Math.floor(window.innerWidth * 0.9) + "px";
      cropCanvas.style.height = "auto";
    }
  }
  window.addEventListener('resize', () => {
    if (cropModal.style.display === "flex") {
      ensureCropCanvasCssSize();
      drawCropOverlay();
    }
  });

  function setDiag(text) { diag.textContent = text; }

  function resizePreview() {
    const vpW = Math.max(320, window.innerWidth - 40);
    const reserved = Math.max(160, controls.offsetHeight + 40);
    const vpH = Math.max(240, window.innerHeight - reserved);

    const ar = camW / camH;
    let drawW = vpW;
    let drawH = Math.round(drawW / ar);
    if (drawH > vpH) {
      drawH = vpH;
      drawW = Math.round(drawH * ar);
    }

    video.style.width = drawW + 'px';
    video.style.height = drawH + 'px';
  }
  window.addEventListener('resize', resizePreview);

  async function countCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.filter(d => d.kind === 'videoinput').length;
    } catch { return 1; }
  }

  async function tryGet(constraints) {
    try { return await navigator.mediaDevices.getUserMedia(constraints); }
    catch(e){ return null; }
  }

  async function startCamera(preferredFacing = currentFacingMode) {
    try {
      if (currentStream) currentStream.getTracks().forEach(t => t.stop());
      const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setDiag('Camera API not available. Use Safari/Chrome over HTTPS.');
        return;
      }
      if (insecure) setDiag('Not HTTPS (or localhost) ‚Äî camera may be blocked.');

      const attempts = [
        { label: 'rear+max',   c: { video: { facingMode: { ideal: preferredFacing }, width: { ideal: 9999 }, height: { ideal: 9999 } } } },
        { label: 'rear',       c: { video: { facingMode: { ideal: preferredFacing } } } },
        { label: 'front',      c: { video: { facingMode: { ideal: (preferredFacing==='environment'?'user':'environment') } } } },
        { label: 'any',        c: { video: true } },
      ];

      let used = null, stream = null, lastErr = null;
      for (const a of attempts) {
        try { stream = await navigator.mediaDevices.getUserMedia(a.c); used = a.label; break; }
        catch(e){ lastErr = e; }
      }
      if (!stream) {
        console.error('getUserMedia failed:', lastErr);
        alert('Unable to access camera. If embedded (e.g., Schoology), open in a new tab. Ensure HTTPS and grant permission.');
        setDiag('Failed to start camera: ' + (lastErr && (lastErr.name+': '+lastErr.message)));
        return;
      }

      currentStream = stream;
      video.srcObject = stream;
      await new Promise(res => video.onloadedmetadata = res);

      camW = video.videoWidth || camW;
      camH = video.videoHeight || camH;
      setDiag(`Camera: ${used} | Resolution: ${camW}√ó${camH}`);
      flipBtn.style.display = (await countCameras()) > 1 ? 'inline-block' : 'none';

      resizePreview();
    } catch (err) {
      console.error('startCamera exception:', err);
      setDiag('Camera error: ' + err.message);
    }
  })();
</script>

</body>
</html>
